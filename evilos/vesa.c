#include <multiboot.h>
#include <vbe.h>
#include <vesa.h>
#include <bmp.h>



static e32 VESA_SCREEN_X_MAX = 800 ;
static e32 VESA_SCREEN_Y_MAX = 600 ;
u32   *VESA_VEDIO_ADDR=NULL;

#define ASC_WIDTH                      8
#define CHS_WIDTH                      16
#define SPACING                        2
#define CHAR_HEIGHT                    16

#define ASC_NUM 256
 u8 *ASC;
 
 u8 ASCII[]=
{

0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,/*" ",32*/
0x00,0x00,0x00,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x00,0x00,0x18,0x18,0x00,0x00,/*"!",33*/
0x00,0x48,0x6C,0x24,0x12,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,/*""",34*/
0x00,0x00,0x00,0x24,0x24,0x24,0x7F,0x12,0x12,0x12,0x7F,0x12,0x12,0x12,0x00,0x00,/*"#",35*/
0x00,0x00,0x08,0x1C,0x2A,0x2A,0x0A,0x0C,0x18,0x28,0x28,0x2A,0x2A,0x1C,0x08,0x08,/*"$",36*/
0x00,0x00,0x00,0x22,0x25,0x15,0x15,0x15,0x2A,0x58,0x54,0x54,0x54,0x22,0x00,0x00,/*"%",37*/
0x00,0x00,0x00,0x0C,0x12,0x12,0x12,0x0A,0x76,0x25,0x29,0x11,0x91,0x6E,0x00,0x00,/*"&",38*/
0x00,0x06,0x06,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,/*"'",39*/
0x00,0x40,0x20,0x10,0x10,0x08,0x08,0x08,0x08,0x08,0x08,0x10,0x10,0x20,0x40,0x00,/*"(",40*/
0x00,0x02,0x04,0x08,0x08,0x10,0x10,0x10,0x10,0x10,0x10,0x08,0x08,0x04,0x02,0x00,/*")",41*/
0x00,0x00,0x00,0x00,0x08,0x08,0x6B,0x1C,0x1C,0x6B,0x08,0x08,0x00,0x00,0x00,0x00,/*"*",42*/
0x00,0x00,0x00,0x00,0x08,0x08,0x08,0x08,0x7F,0x08,0x08,0x08,0x08,0x00,0x00,0x00,/*"+",43*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x06,0x04,0x03,/*",",44*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,/*"-",45*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x06,0x00,0x00,/*".",46*/
0x00,0x00,0x80,0x40,0x40,0x20,0x20,0x10,0x10,0x08,0x08,0x04,0x04,0x02,0x02,0x00,/*"/",47*/
0x00,0x00,0x00,0x18,0x24,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x24,0x18,0x00,0x00,/*"0",48*/
0x00,0x00,0x00,0x08,0x0E,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x3E,0x00,0x00,/*"1",49*/
0x00,0x00,0x00,0x3C,0x42,0x42,0x42,0x20,0x20,0x10,0x08,0x04,0x42,0x7E,0x00,0x00,/*"2",50*/
0x00,0x00,0x00,0x3C,0x42,0x42,0x20,0x18,0x20,0x40,0x40,0x42,0x22,0x1C,0x00,0x00,/*"3",51*/
0x00,0x00,0x00,0x20,0x30,0x28,0x24,0x24,0x22,0x22,0x7E,0x20,0x20,0x78,0x00,0x00,/*"4",52*/
0x00,0x00,0x00,0x7E,0x02,0x02,0x02,0x1A,0x26,0x40,0x40,0x42,0x22,0x1C,0x00,0x00,/*"5",53*/
0x00,0x00,0x00,0x38,0x24,0x02,0x02,0x1A,0x26,0x42,0x42,0x42,0x24,0x18,0x00,0x00,/*"6",54*/
0x00,0x00,0x00,0x7E,0x22,0x22,0x10,0x10,0x08,0x08,0x08,0x08,0x08,0x08,0x00,0x00,/*"7",55*/
0x00,0x00,0x00,0x3C,0x42,0x42,0x42,0x24,0x18,0x24,0x42,0x42,0x42,0x3C,0x00,0x00,/*"8",56*/
0x00,0x00,0x00,0x18,0x24,0x42,0x42,0x42,0x64,0x58,0x40,0x40,0x24,0x1C,0x00,0x00,/*"9",57*/
0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,/*":",58*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x08,0x08,0x04,/*";",59*/
0x00,0x00,0x00,0x40,0x20,0x10,0x08,0x04,0x02,0x04,0x08,0x10,0x20,0x40,0x00,0x00,/*"<",60*/
0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0x00,0x00,0x00,0x7F,0x00,0x00,0x00,0x00,0x00,/*"=",61*/
0x00,0x00,0x00,0x02,0x04,0x08,0x10,0x20,0x40,0x20,0x10,0x08,0x04,0x02,0x00,0x00,/*">",62*/
0x00,0x00,0x00,0x3C,0x42,0x42,0x46,0x40,0x20,0x10,0x10,0x00,0x18,0x18,0x00,0x00,/*"?",63*/
0x00,0x00,0x00,0x1C,0x22,0x5A,0x55,0x55,0x55,0x55,0x2D,0x42,0x22,0x1C,0x00,0x00,/*"@",64*/
0x00,0x00,0x00,0x08,0x08,0x18,0x14,0x14,0x24,0x3C,0x22,0x42,0x42,0xE7,0x00,0x00,/*"A",65*/
0x00,0x00,0x00,0x1F,0x22,0x22,0x22,0x1E,0x22,0x42,0x42,0x42,0x22,0x1F,0x00,0x00,/*"B",66*/
0x00,0x00,0x00,0x7C,0x42,0x42,0x01,0x01,0x01,0x01,0x01,0x42,0x22,0x1C,0x00,0x00,/*"C",67*/
0x00,0x00,0x00,0x1F,0x22,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x22,0x1F,0x00,0x00,/*"D",68*/
0x00,0x00,0x00,0x3F,0x42,0x12,0x12,0x1E,0x12,0x12,0x02,0x42,0x42,0x3F,0x00,0x00,/*"E",69*/
0x00,0x00,0x00,0x3F,0x42,0x12,0x12,0x1E,0x12,0x12,0x02,0x02,0x02,0x07,0x00,0x00,/*"F",70*/
0x00,0x00,0x00,0x3C,0x22,0x22,0x01,0x01,0x01,0x71,0x21,0x22,0x22,0x1C,0x00,0x00,/*"G",71*/
0x00,0x00,0x00,0xE7,0x42,0x42,0x42,0x42,0x7E,0x42,0x42,0x42,0x42,0xE7,0x00,0x00,/*"H",72*/
0x00,0x00,0x00,0x3E,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x3E,0x00,0x00,/*"I",73*/
0x00,0x00,0x00,0x7C,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x11,0x0F,/*"J",74*/
0x00,0x00,0x00,0x77,0x22,0x12,0x0A,0x0E,0x0A,0x12,0x12,0x22,0x22,0x77,0x00,0x00,/*"K",75*/
0x00,0x00,0x00,0x07,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x42,0x7F,0x00,0x00,/*"L",76*/
0x00,0x00,0x00,0x77,0x36,0x36,0x36,0x36,0x2A,0x2A,0x2A,0x2A,0x2A,0x6B,0x00,0x00,/*"M",77*/
0x00,0x00,0x00,0xE3,0x46,0x46,0x4A,0x4A,0x52,0x52,0x52,0x62,0x62,0x47,0x00,0x00,/*"N",78*/
0x00,0x00,0x00,0x1C,0x22,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x22,0x1C,0x00,0x00,/*"O",79*/
0x00,0x00,0x00,0x3F,0x42,0x42,0x42,0x42,0x3E,0x02,0x02,0x02,0x02,0x07,0x00,0x00,/*"P",80*/
0x00,0x00,0x00,0x1C,0x22,0x41,0x41,0x41,0x41,0x41,0x4D,0x53,0x32,0x1C,0x60,0x00,/*"Q",81*/
0x00,0x00,0x00,0x3F,0x42,0x42,0x42,0x3E,0x12,0x12,0x22,0x22,0x42,0xC7,0x00,0x00,/*"R",82*/
0x00,0x00,0x00,0x7C,0x42,0x42,0x02,0x04,0x18,0x20,0x40,0x42,0x42,0x3E,0x00,0x00,/*"S",83*/
0x00,0x00,0x00,0x7F,0x49,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x1C,0x00,0x00,/*"T",84*/
0x00,0x00,0x00,0xE7,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x3C,0x00,0x00,/*"U",85*/
0x00,0x00,0x00,0xE7,0x42,0x42,0x22,0x24,0x24,0x14,0x14,0x18,0x08,0x08,0x00,0x00,/*"V",86*/
0x00,0x00,0x00,0x6B,0x49,0x49,0x49,0x49,0x55,0x55,0x36,0x22,0x22,0x22,0x00,0x00,/*"W",87*/
0x00,0x00,0x00,0xE7,0x42,0x24,0x24,0x18,0x18,0x18,0x24,0x24,0x42,0xE7,0x00,0x00,/*"X",88*/
0x00,0x00,0x00,0x77,0x22,0x22,0x14,0x14,0x08,0x08,0x08,0x08,0x08,0x1C,0x00,0x00,/*"Y",89*/
0x00,0x00,0x00,0x7E,0x21,0x20,0x10,0x10,0x08,0x04,0x04,0x42,0x42,0x3F,0x00,0x00,/*"Z",90*/
0x00,0x78,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x78,0x00,/*"[",91*/
0x00,0x00,0x02,0x02,0x04,0x04,0x08,0x08,0x08,0x10,0x10,0x20,0x20,0x20,0x40,0x40,/*"\",92*/
0x00,0x1E,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x1E,0x00,/*"]",93*/
0x00,0x38,0x44,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,/*"^",94*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,/*"_",95*/
0x00,0x06,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,/*"`",96*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x42,0x78,0x44,0x42,0x42,0xFC,0x00,0x00,/*"a",97*/
0x00,0x00,0x00,0x03,0x02,0x02,0x02,0x1A,0x26,0x42,0x42,0x42,0x26,0x1A,0x00,0x00,/*"b",98*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x44,0x02,0x02,0x02,0x44,0x38,0x00,0x00,/*"c",99*/
0x00,0x00,0x00,0x60,0x40,0x40,0x40,0x78,0x44,0x42,0x42,0x42,0x64,0xD8,0x00,0x00,/*"d",100*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x42,0x7E,0x02,0x02,0x42,0x3C,0x00,0x00,/*"e",101*/
0x00,0x00,0x00,0xF0,0x88,0x08,0x08,0x7E,0x08,0x08,0x08,0x08,0x08,0x3E,0x00,0x00,/*"f",102*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7C,0x22,0x22,0x1C,0x02,0x3C,0x42,0x42,0x3C,/*"g",103*/
0x00,0x00,0x00,0x03,0x02,0x02,0x02,0x3A,0x46,0x42,0x42,0x42,0x42,0xE7,0x00,0x00,/*"h",104*/
0x00,0x00,0x00,0x0C,0x0C,0x00,0x00,0x0E,0x08,0x08,0x08,0x08,0x08,0x3E,0x00,0x00,/*"i",105*/
0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x38,0x20,0x20,0x20,0x20,0x20,0x20,0x22,0x1E,/*"j",106*/
0x00,0x00,0x00,0x03,0x02,0x02,0x02,0x72,0x12,0x0A,0x16,0x12,0x22,0x77,0x00,0x00,/*"k",107*/
0x00,0x00,0x00,0x0E,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x3E,0x00,0x00,/*"l",108*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0x92,0x92,0x92,0x92,0x92,0xB7,0x00,0x00,/*"m",109*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3B,0x46,0x42,0x42,0x42,0x42,0xE7,0x00,0x00,/*"n",110*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x42,0x42,0x42,0x42,0x42,0x3C,0x00,0x00,/*"o",111*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1B,0x26,0x42,0x42,0x42,0x22,0x1E,0x02,0x07,/*"p",112*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x44,0x42,0x42,0x42,0x44,0x78,0x40,0xE0,/*"q",113*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x77,0x4C,0x04,0x04,0x04,0x04,0x1F,0x00,0x00,/*"r",114*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7C,0x42,0x02,0x3C,0x40,0x42,0x3E,0x00,0x00,/*"s",115*/
0x00,0x00,0x00,0x00,0x00,0x08,0x08,0x3E,0x08,0x08,0x08,0x08,0x08,0x30,0x00,0x00,/*"t",116*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x63,0x42,0x42,0x42,0x42,0x62,0xDC,0x00,0x00,/*"u",117*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE7,0x42,0x24,0x24,0x14,0x08,0x08,0x00,0x00,/*"v",118*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xEB,0x49,0x49,0x55,0x55,0x22,0x22,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x76,0x24,0x18,0x18,0x18,0x24,0x6E,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE7,0x42,0x24,0x24,0x14,0x18,0x08,0x08,0x07,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x22,0x10,0x08,0x08,0x44,0x7E,0x00,0x00,
0x00,0xC0,0x20,0x20,0x20,0x20,0x20,0x10,0x20,0x20,0x20,0x20,0x20,0x20,0xC0,0x00,
0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
0x00,0x06,0x08,0x08,0x08,0x08,0x08,0x10,0x08,0x08,0x08,0x08,0x08,0x08,0x06,0x00,
0x0C,0x32,0xC2,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};
struct point_t cur;

e32 vesa_init(void){
	e32 i,screen_size;
	if(VESA_VEDIO_ADDR!=NULL)
		return 0;
	vbe_mode_t *mode = get_vbe_mode_info();
	vbe_controller_t *control=get_vbe_controller_info();
	if (control->version < 0x0200){
		return 0;
   	}
	//pre32f("version:%d\n",control->version);
	//pre32f("oem_string:%\n",control->oem_string);
	//pre32f("total_memory:%d\n",control->total_memory);
	//pre32f("version:%d\n",control->version);
	VESA_SCREEN_X_MAX = mode->x_resolution;
	VESA_SCREEN_Y_MAX = mode->y_resolution;
	VESA_VEDIO_ADDR = (u32 *) mode->phys_base;
	//pre32f("VESA_VEDIO_ADDR:%x\n",VESA_VEDIO_ADDR);
	//pre32f("VESA_SCREEN_X_MAX:%d\n",VESA_SCREEN_X_MAX);
  	//pre32f("VESA_SCREEN_Y_MAX:%d\n",VESA_SCREEN_Y_MAX);
	screen_size = VESA_SCREEN_X_MAX * VESA_SCREEN_Y_MAX;
	for(i = 0; i < screen_size; i++) 
		VESA_VEDIO_ADDR[i] = 0x000000;
	cur.x=cur.y=0;
	ASC=(u8 *)ASCII;
	//char buf[256];
	//sprintf(buf,"aa:%x",VESA_VEDIO_ADDR);
	//vesa_draw_string(0,0,buf);	
	return 1;
}
void vesa_put_pixel(e32 x,e32 y,e32 color){
	if(x<0||y<0||x>=VESA_SCREEN_X_MAX||y>=VESA_SCREEN_Y_MAX)
		return;
		VESA_VEDIO_ADDR[y*VESA_SCREEN_X_MAX+x]=color;
}
void vesa_draw_vline(e32 x1,e32 x2,e32 y, e32 color){
	register e32 i;
	e32 start_pos,end_pos;
	start_pos=y*VESA_SCREEN_X_MAX+x1;
  	end_pos=y*VESA_SCREEN_X_MAX+x2;
	for(i=start_pos;i<end_pos;i++)
 		 VESA_VEDIO_ADDR[i]=color;
}
void vesa_draw_hline(e32 y1,e32 y2,e32 x, e32 color){
	register e32 i;
	for(i=y1;i<y2;i++)
		vesa_put_pixel(x,i,color);
}
void vesa_draw_line(u32 x1,u32 y1,u32 x2,u32 y2,u32 color){
	int t;
	int xerr = 0, yerr = 0, delta_x, delta_y, distance;
	int incx, incy, row, col;
	delta_x = x2 - x1; //计算坐标增量
	delta_y = y2 - y1;
	row = x1;
	col = y1;
	if (delta_x > 0) {
		incx = 1; //设置单步方向
	} else if (delta_x == 0) {
		incx = 0;//垂直线
	} else {
		incx = -1;
		delta_x = -delta_x;
	}
	if (delta_y > 0) {
		incy = 1;
	} else if (delta_y == 0) {
		incy = 0;//水平线
	} else {
		incy = -1;
		delta_y = -delta_y;
	}
	if (delta_x > delta_y) {
		distance = delta_x; //选取基本增量坐标轴
	} else {
		distance = delta_y;
	}
	for (t = 0; t <= distance + 1; t++){ //画线输出
		vesa_put_pixel(row, col , color);//画点
		xerr += delta_x;
		yerr += delta_y;
		if (xerr > distance) {
			xerr -= distance;
			row += incx;
		}
		if (yerr > distance) {
			yerr -= distance;
			col += incy;
		}
	}
}

void vesa_clear_screen(void){
	e32  screen_size,i;
	screen_size = VESA_SCREEN_X_MAX * VESA_SCREEN_Y_MAX;
  	for(i = 0; i < screen_size; i++) 
	VESA_VEDIO_ADDR[i] =0;
}
void vesa_fill_rect(e32 x,e32 y,e32 w,e32 h,u32 color){
	register e32 i;
	for(i=y;i<y+h;i++)
		vesa_draw_vline(x,x+w,i,color);
}
void vesa_put_ascii(e32 x, e32 y, u8 ch, e32 color){
    register e32 i,j;
    for (i = 0; i < CHAR_HEIGHT; i++)
	  for (j=0;j<ASC_WIDTH;j++)
	  if(( *(ASC+ch*ASC_WIDTH+i)>>(ASC_WIDTH-j-1) )&1)
	  vesa_put_pixel(x+j,y+i,color);
}
/*void VesaVramToMsBuf(RECT msRect,RECT sRect,e32* buf)
{
	register e32 i,j;
	e32      w,h;

	h=sRect.bottom-sRect.top;
	w=sRect.right-sRect.left;

	for(j=0;j<h;j++)
	for(i=0;i<w;i++)
				buf[(j+sRect.top-msRect.top)*(msRect.right-msRect.left)+i+sRect.left-msRect.left]=
				VESA_VEDIO_ADDR[(sRect.top+j)*VESA_SCREEN_X_MAX+sRect.left+i];

}*/

void vesa_vram_to_buf( e32 x1, e32 y1, e32 x2, e32 y2,e32* buf){
	register e32 i,j;
	for(j=0;j<y2-y1;j++)
		for(i=0;i<x2-x1;i++)
			  if(x1+i>=0 && x1+i<VESA_SCREEN_X_MAX && y1+j>=0 && y1+j<VESA_SCREEN_Y_MAX)
				buf[j*(x2-x1)+i]=VESA_VEDIO_ADDR[(y1+j)*VESA_SCREEN_X_MAX+x1+i];
}
void vesa_buf_to_vram( e32 x1, e32 y1, e32 x2, e32 y2,e32* buf){
	register e32 i,j;
	for(j=0;j<y2-y1;j++)
		for(i=0;i<x2-x1;i++)
				VESA_VEDIO_ADDR[(y1+j)*VESA_SCREEN_X_MAX+x1+i]=buf[j*(x2-x1)+i];                             
}

e32 vesa_get_screen_width(void){
	  return VESA_SCREEN_X_MAX;
}
e32 vesa_get_screen_height(void){
	  return VESA_SCREEN_Y_MAX;
}
void vesa_screen_scroll_down(e32 n){
	//u8* ToStart=(u8*)&VESA_VEDIO_ADDR[VESA_SCREEN_X_MAX*n-1];
	u8* ToEnd=(u8*)&VESA_VEDIO_ADDR[VESA_SCREEN_X_MAX*VESA_SCREEN_Y_MAX-1];
	u8* FromStart=(u8*)&VESA_VEDIO_ADDR[0];
	u8* FromEnd=(u8*)&VESA_VEDIO_ADDR[VESA_SCREEN_X_MAX*(VESA_SCREEN_Y_MAX-n)-1];
	register u8* p1;
	register u8* p2;
	for(p1=FromEnd,p2=ToEnd;p1>FromStart;p1--){
		*p2=*p1;
		p2--;
	}

}
void vesa_screen_scroll_up(e32 n){
	u8* ToStart=(u8*)&VESA_VEDIO_ADDR[0];
	//u8* ToEnd=(u8*)&VESA_VEDIO_ADDR[VESA_SCREEN_X_MAX*(VESA_SCREEN_Y_MAX-n)-1];
	u8* FromStart=(u8*)&VESA_VEDIO_ADDR[VESA_SCREEN_X_MAX*n];
	u8* FromEnd=(u8*)&VESA_VEDIO_ADDR[VESA_SCREEN_X_MAX*VESA_SCREEN_Y_MAX-1];
    register u8* p1;
	register u8* p2;
	for(p1=FromStart,p2=ToStart;p1<FromEnd;p1++){
		   	*p2=*p1;
				 p2++;
	}
}

 

// 色调合成函数
e32 vesa_compond_rgb( u8 r , u8 g , u8 b ){
  union{
     e32 color ;
    struct{
      u8 b : 5 ;
      u8 g : 6 ;
      u8 r : 5 ;
    } ;
  } u ;
  u.r = r % 32 ;
  u.g = g % 64 ;
  u.b = b % 32 ;
  return u.color ;
}

// 画点函数
void vesa_draw_poe32(  e32 x ,  e32 y , e32 color ){  
   e32 x_max = VESA_SCREEN_X_MAX - 1 ; // 每行像素数
   e32 y_max = VESA_SCREEN_Y_MAX - 1 ; // 每列像素数

  // 防止越界
  if( x > x_max ){
    return ;
  }
  if( y > y_max ){
    return ;
  }

  // 取得显存线性地址
  u32 *video = ( u32 * )( * ( (  u32 *)VESA_VEDIO_ADDR ) ) ;

  // 计算点的偏移量
   e32 offset = y * ( x_max + 1 ) + x ;  
  *( video + offset ) = color ;
}

// 取得指定点色彩
e32 vesa_get_poe32_color(  e32 x ,  e32 y ){
   e32 x_max = VESA_SCREEN_X_MAX - 1 ; // 每行像素数
   e32 y_max = VESA_SCREEN_Y_MAX - 1 ; // 每列像素数

  // 防止越界
  if( x > x_max ){
    x = x_max ;
  }
  if( y > y_max ){
    y = y_max ;
  }

  // 取得显存线性地址
  u32 *video = ( u32 * )( * ( (  u32 *)VESA_VEDIO_ADDR ) ) ;

  // 计算点的偏移量
   e32 offset = y * ( x_max + 1 ) + x ;  
  return *( video + offset ) ;
}

// 清屏函数
void vesa_clean_screen( u32 color ){
  vesa_fill_rect( 0 , 0 , VESA_SCREEN_X_MAX - 1 , VESA_SCREEN_Y_MAX - 1 , color ) ;
}

// 图片拷贝函数
void vesa_copy_picture_from_screen(e32 x ,  e32 y , u32 *object_picture_addr ,  e32 picture_width ,  e32 picture_height )
{
  for( e32 j = 0 ; j < picture_height ; ++j ){
    for( e32 i = 0 ; i < picture_width ; ++i ){
      *( object_picture_addr + j * picture_width + i ) = vesa_get_poe32_color( x + i , y + j ) ;
    }
  }
}

// 图片拷贝函数
void vesa_copy_picture_to_screen(  e32 x ,  e32 y , u32 *source_picture_addr ,  e32 picture_width ,  e32 picture_height )
{
  for( e32 j = 0 ; j < picture_height ; ++j ){
    for( e32 i = 0 ; i < picture_width ; ++i ){
      vesa_draw_poe32( x + i , y + j , *( source_picture_addr + j * picture_width + i ) ) ;
    }
  }
}

// 画横线函数
void vesa_draw_x_line(  e32 y ,  e32 x1 ,  e32 x2 , e32 color ){
  for( e32 x = x1 ; x < x2 + 1 ; ++x ){
    vesa_draw_poe32( x , y , color ) ;
  }
}

// 画竖线函数
void vesa_draw_y_line(  e32 x ,  e32 y1 ,  e32 y2 , e32 color ){
  for( e32 y = y1 ; y < y2 + 1 ; ++y ){
    vesa_draw_poe32( x , y , color ) ;
  }
}

// 画矩形函数
void vesa_draw_rect(  e32 x1 ,  e32 y1 ,  e32 x2 ,e32  y2 , e32 color , e32 dose_fill_it ){
  vesa_draw_x_line( y1 , x1 , x2 , color ) ;
  vesa_draw_x_line( y2 , x1 , x2 , color ) ;
  vesa_draw_y_line( x1 , y1 , y2 , color ) ;
  vesa_draw_y_line( x2 , y1 , y2 , color ) ;

  if( dose_fill_it ){
    vesa_fill_rect( x1 , y1 , x2 , y2 , color ) ;
  }
}

void vesa_printf(e32 x,e32 y,char *fmt,...){
	int i;
	char buf[1024];
	va_list args;
	va_start(args, fmt);
	i = vsprintf(buf, fmt, args);
	va_end(args);
	vesa_draw_string(x,y,buf);
}

void vesa_draw_string(e32 x,e32 y,e8 *str){
	vesa_draw_string_with_color(x, y,str,0xffffffff,0x00000000);
}
void vesa_draw_char(e32 x,e32 y,u16 ch){
	vesa_draw_char_witdh_color( x, y,ch,0xffffffff,0x00000000);
}

void vesa_draw_char_witdh_color(e32 x,e32 y,u16 ch,u32 frcolor,u32 bgcolor){
	u32 i, j;
	u16 code, z;
	u8 *lp;
	u32 *pp;
	code=ch;
	if(code<0x20) return;
	if(code<0x7f)
	{	if(x>(VESA_SCREEN_X_MAX-1)) return;
		code=code-0x20;
		lp = ASCII + code * 16;
		for(i=0; i<16; i++){
			z = *lp++;
			pp = (u32 *)(VESA_VEDIO_ADDR+(y+i)*VESA_SCREEN_X_MAX+x);
			for(j=0; j<8; j++){
				if(z & 0x01)
				//if(z & 0x80)
				{*pp++ = frcolor;}
				else
				{*pp++ = bgcolor;}
				//z = z <<1;
				z=z>>1;
			}
		}
		x =x + 8;
	}
	else if(code>0xa1a1){
		if(x>(VESA_SCREEN_X_MAX-1)) return;
		code = code - 0xa1a1;
		if(code>0x0f00) code = code - 0x600;
		lp = ((u8 *)0x40000 + ((code>>8)*94 + (code&0xff)) * 32);
		for(i=0; i<16; i++){
			z = *lp++;
			z = (z << 8) + *lp++;
			pp = (u32 *)(VESA_VEDIO_ADDR+(y+i)*VESA_SCREEN_X_MAX+cur.x);
			for(j=0; j<16; j++){
				if(z & 0x8000)
				{*pp++ = frcolor;}
				else
				{*pp++ = bgcolor;}
				z = z <<1;
			}
		}
		x = x + 16;
	} 	
}
void vesa_draw_string_with_color(e32 x,e32 y,e8 *str,u32 frcolor,u32 bgcolor){
	u16 code;
	while((*str != '\0'))
	{	code = *str++;
		if(code > 0x80)
		code=(code<<8)+ *str++;
		vesa_draw_char_witdh_color(x,y,code,frcolor,bgcolor);
		x+=8;
	} 	
}


// 显示英文
void vesa_pre32_english(  e32 x ,  e32 y ,  e32 pos_in_font , e32 color ){
  u8 *english_font_addr = ( u8 * )0x30200 + pos_in_font * 16 ; // 一个英文 16 字节

  union{
    u8 ch ;
    struct{
      u8 ch0 : 1 ;
      u8 ch1 : 1 ;
      u8 ch2 : 1 ;
      u8 ch3 : 1 ;
      u8 ch4 : 1 ;
      u8 ch5 : 1 ;
      u8 ch6 : 1 ;
      u8 ch7 : 1 ;
    } ;
  } u ;

  for( e32 j = 0 ; j < 16 ; ++j ){ // 一个英文 16 行    
    u.ch = english_font_addr[ j ] ;
    e32 offset = x ;
    if( u.ch7 ){
      vesa_draw_poe32( offset , y , color ) ;
    }
    if( u.ch6 ){
      vesa_draw_poe32( offset + 1  , y , color ) ;
    }
    if( u.ch5 ){
      vesa_draw_poe32( offset + 2 , y , color ) ;
    }
    if( u.ch4 ){
      vesa_draw_poe32( offset + 3 , y , color ) ;
    }
    if( u.ch3 ){
      vesa_draw_poe32( offset + 4 , y , color ) ;
    }
    if( u.ch2 ){
      vesa_draw_poe32( offset + 5 , y , color ) ;
    }
    if( u.ch1 ){
      vesa_draw_poe32( offset + 6 , y , color ) ;
    }
    if( u.ch0 ){
      vesa_draw_poe32( offset + 7 , y , color ) ;
    }
    y++ ; // 显示下一行
  }
}

// 显示汉字
void vesa_pre32_chinese(  e32 x ,  e32 y ,  e32 pos_in_font , e32 color )
{
  u8 *chinese_font_addr = ( u8 * )0x30000 + pos_in_font * 32 ; // 一个汉字 32 字节

  union{
    u8 ch ;
    struct{
      u8 ch0 : 1 ;
      u8 ch1 : 1 ;
      u8 ch2 : 1 ;
      u8 ch3 : 1 ;
      u8 ch4 : 1 ;
      u8 ch5 : 1 ;
      u8 ch6 : 1 ;
      u8 ch7 : 1 ;
    } ;
  } u ;

  for( e32 j = 0 ; j < 16 ; ++j ){ // 一个汉字 16 行
    for( e32 i = 0 ; i < 2 ; ++i ){ // 每行 2 个字节 ( 16 位 )
      u.ch = chinese_font_addr[ j * 2 + i ] ;
      e32 offset = x + i * 8 ; // 一个字节 8 个像素
      if( u.ch7 ){
        vesa_draw_poe32( offset , y , color ) ;
      }
      if( u.ch6 ){
        vesa_draw_poe32( offset + 1  , y , color ) ;
      }
      if( u.ch5 ){
        vesa_draw_poe32( offset + 2 , y , color ) ;
      }
      if( u.ch4 ){
        vesa_draw_poe32( offset + 3 , y , color ) ;
      }
      if( u.ch3 ){
        vesa_draw_poe32( offset + 4 , y , color ) ;
      }
      if( u.ch2 ){
        vesa_draw_poe32( offset + 5 , y , color ) ;
      }
      if( u.ch1 ){
        vesa_draw_poe32( offset + 6 , y , color ) ;
      }
      if( u.ch0 ){
        vesa_draw_poe32( offset + 7 , y , color ) ;
      }    
    }
    y++ ; // 显示下一行
  }
}

// 显示 pbmp 格式的图片
void vesa_show_bmp_picture(  e32 x ,  e32 y , void *bmp_addr , e32 mask_color , e32 dose_use_mask_color )
{ 
  // 这里只支持 windows 标准 16 位 bmp 格式图片，（1:5:5:5）
  struct bmp_bmp_head_struct *bmp_head = ( struct bmp_bmp_head_struct * )bmp_addr ;
  e32 width = bmp_head->info_head.width ;
  e32 height = bmp_head->info_head.height ;

  // 下面记算存储每个点的色彩的信息所在的位置
  e32 *color = ( e32 * )( (  e32 )bmp_addr + bmp_head->offset ) ;

  // 由于一行的字节数比须是 4 的倍数，因此，这里先计算每行需要的填充数，除 2 是因为每个像素两个字节
  e32 fill_length = width * 2 % 4 / 2 ; 

  // bmp 的存放顺序是从下到上，从左到右
  for( e32 i = height - 1 ; i >= 0 ; --i ){
    for( e32 j = 0 ; j < width ; ++j ){
	  // 取得每个点的色彩信息
	  // 由于 windows 默认的是 555 格式，而 pyos 用的是 565 格式，因此先进行一下转换 
      e32 temp_color = vesa_change_color_form_555_to_565( *color ) ;
      if( !dose_use_mask_color || temp_color != mask_color ){  
	    // 画出每个点
        vesa_draw_poe32( x + j , y + i , temp_color ) ;
      }
      ++color ;
    }
    // 填充
    color += fill_length ;
  }
}

// 显示字符在文本模式下
void vesa_pre32_char_under_text_model( e8 x )
{
  static u8 *video = ( u8 * )0xb8000 ;
  *video++ = x ;
  *video++ = 0xf ;
}

// 色调转换函数，把 5:5:5 格式转换成标准的 5:6:5 格式
e32 vesa_change_color_form_555_to_565( e32 color_form_555 )
{
  // 把 555 中间的色彩 * 2，为了掩色处理方便，如果不是 0，则末位恒置 1
  union{
     e32 color ;
    struct{
      u8 b : 5 ;
      u8 g : 6 ;
      u8 r : 5 ;
    } ;
  } u1 ;
  
  union{
     e32 color ;
    struct{
      u8 b : 5 ;
      u8 g : 5 ;
      u8 r : 5 ;
      u8 alpha : 1 ;  // alpha 通道，但这里不用
    } ;
  } u2 ;
  
  u2.color = color_form_555 ;
  u1.r = u2.r ;
  if( u2.g ){
    u1.g = ( e32 )u2.g * 2 + 1 ;
  }
  else{
    u1.g = 0 ;
  }
  u1.b = u2.b ;
  
  return u1.color ;
}
